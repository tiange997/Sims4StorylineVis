import {
  calculateBorderLength,
  drawStoryline,
} from '../../src/js/utils/drawerB'
import { shapeCovering } from '../../src/js/shapeCovering'
import { none } from 'html-webpack-plugin/lib/chunksorter'
import iStoryline from '../../src/js'
import * as d3Fetch from 'd3-fetch'
import Snap from 'snapsvg'
import $ from 'jquery'

let allEventData = [] // Store all event data globally for filtering

// Dynamically generate event type filter checkboxes based on event data
const eventTypeFilterDiv = document.getElementById('eventTypeFilters')
const eventTypeJsonPath = '../../data/json/Match11/Story_Events_Data6.json'

d3Fetch.json(eventTypeJsonPath).then(data => {
  allEventData = data // Store for filtering
  // Get unique event types
  const eventTypes = Array.from(new Set(data.map(ev => ev.eventType))).sort()
  // Generate checkboxes
  eventTypeFilterDiv.innerHTML = '<label>Show Event Types:</label><br>'
  eventTypes.forEach((type, idx) => {
    const id = `eventType_${idx}`
    eventTypeFilterDiv.innerHTML += `
      <input type="checkbox" id="${id}" name="eventTypes" value="${type}" checked>
      <label for="${id}">${type}</label>
    `
  })

  // Add event listener for real-time filtering
  eventTypeFilterDiv.addEventListener('change', () => {
    // Get checked event types
    const checkedTypes = Array.from(
      document.querySelectorAll('input[name="eventTypes"]:checked')
    ).map(cb => cb.value)
    console.log('Filter changed, checked types:', checkedTypes)
    // Redraw events with only checked types
    if (window._drawEventsFilter) {
      window._drawEventsFilter(checkedTypes)
    } else {
      console.warn('window._drawEventsFilter is not defined')
    }
  })
})

main('Match11/simsTest6.json')

// Initialise json files
const jsonRead = d3Fetch.json('../../data/json/Match11/sims2.json') // Info of match
const jsonReadTwo = d3Fetch.json(
  '../../data/json/Match11/Story_Events_Data6.json'
) // Killing info file generated by python
// const jsonDBSCAN = d3Fetch.json('../../data/json/Match11/dbscan.json') // DBSCAN result

// Screen Width and Height
const width = 5000
const height = 1080

// We need to set the total timestamp first
// Sections decide how the interval of timeline display
let totalTimestamp
let lastTimestamp = null
let sections
let sectionsForText

// Canvas Origin
let xOrigin = 350,
  yOrigin = 60

// We have to hard-code this part as we manually define colours
// Saving this for decorating circles
/*let playerColour = {
  Player1: '#ff0000',
  Player2: '#ba000d',
  Player3: '#ff94c2',
  Player4: '#FF7F00', // changed
  Player5: '#ffd149',
}*/

let playerColour = {
  Player1: '#000080', // changed
  Player2: '#00B8D1',
  Player3: '#006400', // changed
  Player4: '#5BB58A',
  Player5: '#9B8BD6',
  Player6: '#ff0000',
  Player7: '#ba000d',
  Player8: '#ff94c2',
  Player9: '#FF7F00', // changed
  Player10: '#ffd149',
}

// Save location info for later use
let locationSet

let mySvg = $('#mySvg')[0]

let pt = mySvg.createSVGPoint()

const svg = Snap('#mySvg')
svg.attr({ viewBox: '0 0 14000 1200' })

// --- Zoom and Pan Logic ---
let viewBox = { x: 0, y: 0, w: 14000, h: 1200 }
let minZoom = 0.1
let maxZoom = 10
let zoomStep = 1.1
let lastTouchDist = null
let isPanning = false
let panStart = { x: 0, y: 0 }
let panViewBoxStart = { x: 0, y: 0 }

function setViewBox(x, y, w, h) {
  viewBox.x = x
  viewBox.y = y
  viewBox.w = w
  viewBox.h = h
  svg.attr({ viewBox: `${x} ${y} ${w} ${h}` })
}

function zoomAt(cx, cy, scale) {
  // cx, cy: client coordinates
  // scale: zoom factor (>1 zoom in, <1 zoom out)
  // Convert client to SVG coordinates
  let pt = mySvg.createSVGPoint()
  pt.x = cx
  pt.y = cy
  let svgPt = pt.matrixTransform(mySvg.getScreenCTM().inverse())
  // Calculate new viewBox
  let newW = viewBox.w / scale
  let newH = viewBox.h / scale
  // Clamp zoom
  let zoomLevel = 14000 / newW
  if (zoomLevel < minZoom) {
    newW = 14000 / minZoom
    newH = 1200 / minZoom
  }
  if (zoomLevel > maxZoom) {
    newW = 14000 / maxZoom
    newH = 1200 / maxZoom
  }
  // Keep svgPt at same position in new viewBox
  let newX = svgPt.x - ((svgPt.x - viewBox.x) / viewBox.w) * newW
  let newY = svgPt.y - ((svgPt.y - viewBox.y) / viewBox.h) * newH
  setViewBox(newX, newY, newW, newH)
}

function resetZoom() {
  setViewBox(0, 0, 14000, 1200)
}

// Mouse wheel and touchpad pinch zoom
mySvg.addEventListener('wheel', function(e) {
  // Only zoom if ctrlKey (touchpad pinch) or if not horizontal scroll
  if (e.ctrlKey || Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
    e.preventDefault()
    let scale = e.deltaY < 0 ? zoomStep : 1 / zoomStep
    zoomAt(e.clientX, e.clientY, scale)
  }
}, { passive: false })

// Touch pinch zoom
mySvg.addEventListener('touchstart', function(e) {
  if (e.touches.length === 2) {
    lastTouchDist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    )
  } else if (e.touches.length === 1) {
    isPanning = true
    panStart.x = e.touches[0].clientX
    panStart.y = e.touches[0].clientY
    panViewBoxStart.x = viewBox.x
    panViewBoxStart.y = viewBox.y
  }
})

mySvg.addEventListener('touchmove', function(e) {
  if (e.touches.length === 2) {
    e.preventDefault()
    let newDist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    )
    if (lastTouchDist) {
      let scale = newDist / lastTouchDist
      zoomAt(
        (e.touches[0].clientX + e.touches[1].clientX) / 2,
        (e.touches[0].clientY + e.touches[1].clientY) / 2,
        scale
      )
    }
    lastTouchDist = newDist
  } else if (e.touches.length === 1 && isPanning) {
    e.preventDefault()
    let dx = e.touches[0].clientX - panStart.x
    let dy = e.touches[0].clientY - panStart.y
    let scaleX = viewBox.w / mySvg.clientWidth
    let scaleY = viewBox.h / mySvg.clientHeight
    setViewBox(
      panViewBoxStart.x - dx * scaleX,
      panViewBoxStart.y - dy * scaleY,
      viewBox.w,
      viewBox.h
    )
  }
}, { passive: false })

mySvg.addEventListener('touchend', function(e) {
  if (e.touches.length < 2) {
    lastTouchDist = null
  }
  if (e.touches.length === 0) {
    isPanning = false
  }
})

// Mouse drag pan
let isMousePanning = false
let mousePanStart = { x: 0, y: 0 }
let mousePanViewBoxStart = { x: 0, y: 0 }
mySvg.addEventListener('mousedown', function(e) {
  if (e.button === 1 || (e.button === 0 && e.ctrlKey)) {
    isMousePanning = true
    mousePanStart.x = e.clientX
    mousePanStart.y = e.clientY
    mousePanViewBoxStart.x = viewBox.x
    mousePanViewBoxStart.y = viewBox.y
    e.preventDefault()
  }
})
window.addEventListener('mousemove', function(e) {
  if (isMousePanning) {
    let dx = e.clientX - mousePanStart.x
    let dy = e.clientY - mousePanStart.y
    let scaleX = viewBox.w / mySvg.clientWidth
    let scaleY = viewBox.h / mySvg.clientHeight
    setViewBox(
      mousePanViewBoxStart.x - dx * scaleX,
      mousePanViewBoxStart.y - dy * scaleY,
      viewBox.w,
      viewBox.h
    )
  }
})
window.addEventListener('mouseup', function(e) {
  if (isMousePanning) {
    isMousePanning = false
  }
})

// Expose resetZoom for button
window.resetZoom = resetZoom

let heroArray = []

async function main(fileName) {
  const iStorylineInstance = new iStoryline()
  const fileUrl = `../../data/${fileName.split('.')[1]}/${fileName}`
  let graph = await iStorylineInstance.loadFile(fileUrl)
  let dbSCANData
  // console.log(graph)

  // Read Json through the Promise and save participants data

  let participantsInfoData = await jsonRead.then(function(result) {
    return result['info']['participants']
  })

  let participantsInfo = []

  for (const element of participantsInfoData) {
    participantsInfo.push(element['participantId'], element['championName'])
  }

  // let dbscan = await jsonDBSCAN.then(function(result) {
  //   dbSCANData = result
  // })

  // Scale to window size
  const containerDom = document.getElementById('mySvg')
  const windowW = containerDom.clientWidth - 20
  const windowH = containerDom.clientHeight - 20
  // graph = iStorylineInstance.scale(80, 10, windowW / 1.2 , windowH / 1.5)
  graph = iStorylineInstance.scale(xOrigin, yOrigin, width*2, height)

  // logStoryInfo(iStorylineInstance._story)

  const session = iStorylineInstance._story._tableMap.get('session')._mat._data

  const characters = graph.characters

  locationSet = iStorylineInstance._story._locations

  let useMode = 0 // set the mode to 0 for test

  // if (locationSet.length === 6) {
  //   useMode = 0 // simple mode with 6 divisions
  // } else if (locationSet.length === 7) {
  //   useMode = 1 // simple mode with 7 divisions
  // } else if (locationSet.length === 17) {
  //   useMode = 2 // complex mode with 17 divisions
  // } else {
  //   warn('Wrong JSON File!')
  // }

  // heroInfo(characters, participantsInfo, useMode)

  // locationBox(locationSet, useMode)

  // drawDBSCAN(dbSCANData, graph)

  const storylines = graph.storylines

  // Timestamp
  const timestamps = iStorylineInstance._story._timeStamps
  totalTimestamp = timestamps[timestamps.length - 1]

  console.log('Match Length: ' + timeStamp(totalTimestamp))

  // convert the last timestamp into minutes

  let min = Math.floor((totalTimestamp / 1000 / 60) << 0),
    sec = Math.floor((totalTimestamp / 1000) % 60)

  // console.log(min + ':' + sec)

  const perTimeStamp = totalTimestamp / 10 //divided by 10

  let perMin = Math.floor((perTimeStamp / 1000 / 60) << 0),
    perSec = Math.floor((perTimeStamp / 1000) % 60)

  // console.log('Per timestamp: ' + perMin + ':' + perSec)

  // timeline()

  storylines.forEach((storyline, idx) => {
    drawStoryline(
      characters[idx],
      storyline,
      session,
      locationSet,
      perTimeStamp,
      participantsInfo
    )
  })

  // Provide a global function for filter UI to call
  window._drawEventsFilter = function(filterTypes) {
    drawEvents(graph, participantsInfo, filterTypes)
  }

  // Initial draw (all types)
  await drawEvents(graph, participantsInfo)

  // await timelineX(graph)

  $('#tip').remove()

  return iStorylineInstance
}

// Draw hero info
function heroInfo(character, participantsInfo, useMode) {
  for (let i = 1; i < participantsInfo.length + 1; i++) {
    console.log(participantsInfo[i - 1])
    if (i % 2 == 0) {
      heroArray.push(participantsInfo[i - 1])
    }
  }

  for (let i = 0; i < 5; i++) {
    heroArray.push(heroArray.shift())
  }

  console.log(heroArray)

  let playerImg = []
  for (let i = 0; i < character.length; i++) {
    playerImg[i] = `../../src/image/Characters/${heroArray[i]}Square.png`
  }

  const teamOneX = 30
  const teamOneY = 50
  const borderOffset = 5

  const iconSize = 42
  const borderSize = 52

  const horizontalAdj = 70
  const verticalAdj = 110

  const yOffset = 70

  let icon = svg.image(playerImg[0], teamOneX, teamOneY, iconSize, iconSize)
  svg.text(teamOneX - 10, teamOneY + yOffset, heroArray[0]).attr({
    fill: playerColour['Player1'],
  })

  // Add decorative border according to the color scheme
  svg
    .rect(
      teamOneX - borderOffset,
      teamOneY - borderOffset,
      borderSize,
      borderSize
    )
    .attr({
      fill: 'none',
      stroke: playerColour['Player1'],
      'stroke-width': '5',
      opacity: 0.7,
    })

  let iconTwo = svg.image(
    playerImg[1],
    teamOneX + horizontalAdj,
    teamOneY,
    iconSize,
    iconSize
  )

  svg.text(teamOneX + horizontalAdj, teamOneY + yOffset, heroArray[1]).attr({
    fill: playerColour['Player2'],
  })

  svg
    .rect(
      teamOneX - borderOffset + horizontalAdj,
      teamOneY - borderOffset,
      borderSize,
      borderSize
    )
    .attr({
      fill: 'none',
      stroke: playerColour['Player2'],
      'stroke-width': '5',
      opacity: 0.7,
    })

  let iconThree = svg.image(
    playerImg[2],
    teamOneX,
    teamOneY + verticalAdj,
    iconSize,
    iconSize
  )

  svg.text(teamOneX - 10, teamOneY + verticalAdj + yOffset, heroArray[2]).attr({
    fill: playerColour['Player3'],
  })

  svg
    .rect(
      teamOneX - borderOffset,
      teamOneY - borderOffset + verticalAdj,
      borderSize,
      borderSize
    )
    .attr({
      fill: 'none',
      stroke: playerColour['Player3'],
      'stroke-width': '5',
      opacity: 0.7,
    })

  let iconFour = svg.image(
    playerImg[3],
    teamOneX + horizontalAdj,
    teamOneY + verticalAdj,
    iconSize,
    iconSize
  )

  svg
    .text(
      teamOneX + horizontalAdj,
      teamOneY + verticalAdj + yOffset,
      heroArray[3]
    )
    .attr({
      fill: playerColour['Player4'],
    })

  svg
    .rect(
      teamOneX - borderOffset + horizontalAdj,
      teamOneY - borderOffset + verticalAdj,
      borderSize,
      borderSize
    )
    .attr({
      fill: 'none',
      stroke: playerColour['Player4'],
      'stroke-width': '5',
      opacity: 0.7,
    })

  let iconFive = svg.image(
    playerImg[4],
    teamOneX,
    teamOneY + verticalAdj * 2,
    iconSize,
    iconSize
  )

  svg
    .text(teamOneX - 10, teamOneY + verticalAdj * 2 + yOffset, heroArray[4])
    .attr({
      fill: playerColour['Player5'],
    })

  svg
    .rect(
      teamOneX - borderOffset,
      teamOneY - borderOffset + verticalAdj * 2,
      borderSize,
      borderSize
    )
    .attr({
      fill: 'none',
      stroke: playerColour['Player5'],
      'stroke-width': '5',
      opacity: 0.7,
    })

  const teamTwoX = teamOneX
  const teamTwoY = 850

  let iconSix = svg.image(playerImg[5], teamTwoX, teamTwoY, iconSize, iconSize)
  svg.text(teamTwoX - 10, teamTwoY + yOffset, heroArray[5]).attr({
    fill: playerColour['Player6'],
  })

  svg
    .rect(
      teamTwoX - borderOffset,
      teamTwoY - borderOffset,
      borderSize,
      borderSize
    )
    .attr({
      fill: 'none',
      stroke: playerColour['Player6'],
      'stroke-width': '5',
      opacity: 0.7,
    })

  let iconSeven = svg.image(
    playerImg[6],
    teamTwoX + horizontalAdj,
    teamTwoY,
    iconSize,
    iconSize
  )

  svg.text(teamTwoX + horizontalAdj, teamTwoY + yOffset, heroArray[6]).attr({
    fill: playerColour['Player7'],
  })

  svg
    .rect(
      teamTwoX - borderOffset + horizontalAdj,
      teamTwoY - borderOffset,
      borderSize,
      borderSize
    )
    .attr({
      fill: 'none',
      stroke: playerColour['Player7'],
      'stroke-width': '5',
      opacity: 0.7,
    })

  let iconEight = svg.image(
    playerImg[7],
    teamTwoX,
    teamTwoY + verticalAdj,
    iconSize,
    iconSize
  )

  svg.text(teamTwoX - 10, teamTwoY + verticalAdj + yOffset, heroArray[7]).attr({
    fill: playerColour['Player8'],
  })

  svg
    .rect(
      teamTwoX - borderOffset,
      teamTwoY - borderOffset + verticalAdj,
      borderSize,
      borderSize
    )
    .attr({
      fill: 'none',
      stroke: playerColour['Player8'],
      'stroke-width': '5',
      opacity: 0.7,
    })

  let iconNine = svg.image(
    playerImg[8],
    teamTwoX + horizontalAdj,
    teamTwoY + verticalAdj,
    iconSize,
    iconSize
  )

  svg
    .text(
      teamTwoX + horizontalAdj,
      teamTwoY + verticalAdj + yOffset,
      heroArray[8]
    )
    .attr({
      fill: playerColour['Player9'],
    })

  svg
    .rect(
      teamTwoX - borderOffset + horizontalAdj,
      teamTwoY - borderOffset + verticalAdj,
      borderSize,
      borderSize
    )
    .attr({
      fill: 'none',
      stroke: playerColour['Player9'],
      'stroke-width': '5',
      opacity: 0.7,
    })

  let iconTen = svg.image(
    playerImg[9],
    teamTwoX,
    teamTwoY + verticalAdj * 2,
    iconSize,
    iconSize
  )

  svg
    .text(teamTwoX - 10, teamTwoY + verticalAdj * 2 + yOffset, heroArray[9])
    .attr({
      fill: playerColour['Player10'],
    })

  svg
    .rect(
      teamTwoX - borderOffset,
      teamTwoY - borderOffset + verticalAdj * 2,
      borderSize,
      borderSize
    )
    .attr({
      fill: 'none',
      stroke: playerColour['Player10'],
      'stroke-width': '5',
      opacity: 0.7,
    })

  const mapSize = 128
  const mapX = 23
  const mapY = 520

  svg.text(mapX + 15, mapY - 25, 'Map Division')

  if (useMode === 0 || useMode == 1) {
    svg.image('../../src/image/MiniMapSimple.png', mapX, mapY, mapSize, mapSize)
  } else {
    svg.image(
      '../../src/image/MiniMapComplex.png',
      mapX,
      mapY,
      mapSize,
      mapSize
    )
  }
}

// Draw timeline basis
function timeline() {
  sections = totalTimestamp / 180000 // 3 mins interval
  sectionsForText = totalTimestamp / 60000
  console.log(sections)
  let accumTimestamp = totalTimestamp / sections
  // let accumTimestampForText = totalTimestamp / sectionsForText
  let timeAidedLine
  let markInBetween
  const distance =
    (width /
      (timeReturn(totalTimestamp)[0] * 60 + timeReturn(totalTimestamp)[1])) *
    180
  const distanceForText =
    (width /
      (timeReturn(totalTimestamp)[0] * 60 + timeReturn(totalTimestamp)[1])) *
    60
  console.log(distance)

  let posX

  for (let segments = 0; segments < sectionsForText; segments++) {
    // draw vertical lines
    posX = xOrigin + distanceForText * segments
    console.log(posX)
    markInBetween = svg.line(posX, 1145, posX, 1160)
    markInBetween.attr({
      fill: 'none',
      stroke: 'black',
      'stroke-dasharray': '4',
    })
  }
  for (let segments = 0; segments < sectionsForText; segments++) {
    // write labels
    let txt = svg.text(
      70 + distance * segments + 95 + 70 + 100,
      1120 + 20 + 60,
      timeStamp(accumTimestamp * segments)
    )

    // draw vertical lines
    posX = xOrigin + distance * segments
    console.log(posX)
    timeAidedLine = svg.line(posX, yOrigin, posX, 1160)
    timeAidedLine.attr({
      fill: 'none',
      stroke: 'black',
      'stroke-dasharray': '4',
    })

    txt.attr({
      'font-size': 30,
    })
  }
}

// Draw X axis of the timeline
async function timelineX(graph) {
  let endPointX = graph.getCharacterX('Player1', lastTimestamp) + 30

  // draw the horizontal line
  const xAxis = svg.line(xOrigin, 1150, endPointX, 1150).attr({
    fill: 'none',
    stroke: 'black',
    'stroke-dasharray': '4',
  })
}

function timeStamp(perTimestamp) {
  let perMin = Math.floor((perTimestamp / 1000 / 60) << 0)
  return perMin + ' Min'
}

function timeReturn(perTimestamp) {
  let perMin = Math.floor((perTimestamp / 1000 / 60) << 0),
    perSec = Math.floor((perTimestamp / 1000) % 60)

  // perMin + ':' + perSec

  return [perMin, perSec]
}

// need to change the order of reading the pictures if reversing the location labels
function locationBox(locationSet, useMode) {
  console.log(locationSet)

  let lineHeight = height / locationSet.length

  // let stripe = svg.image('../../src/image/stripe.svg', 0, 0, 5920, lineHeight)

  // let pat = stripe.pattern(0, 0, 5920, lineHeight)

  // Initialise Rectangles

  let rect = []
  let length = locationSet.length

  // console.log('LEN: ' + length)

  for (let i = 0; i < length; i++) {
    rect[i] = []
  }

  // console.log(rect)

  const textXPosOne = 210
  const textXPosTwo = 6380

  let localHeight = 0

  let mask
  let img

  for (let i = 0; i < length; i++) {
    localHeight = localHeight + lineHeight

    if ((i + 1) % 2 !== 0) {
      rect[i] = svg
        .rect(xOrigin, lineHeight * i + yOrigin, width, lineHeight)
        .attr({
          fill: 'rgba(128, 128, 128, 0.5)',
          fillOpacity: '0.1',
          stroke: 'none',
        })
      // console.log('y Value: ' + (lineHeight * (i + 1)) / 2 + yOrigin)
      svg
        .text(
          textXPosOne,
          localHeight + yOrigin - lineHeight / 2,
          locationSet[i]
        )
        .attr({ 'font-size': 17 })
        .hover(
          event => {
            pt.x = event.clientX
            pt.y = event.clientY

            pt = pt.matrixTransform(mySvg.getScreenCTM().inverse())

            const tipWindowSize = 200
            const maskSize = 200

            let tipX = pt.x
            let tipY = pt.y

            if (i > 4) {
              tipX -= 100
              tipY -= 100
            }

            mask = svg
              .rect(tipX, tipY, maskSize, maskSize, 10, 10)
              .attr({ fill: 'yellow' })
            // draw for complex and simple version
            if (useMode === 0) {
              img = svg.image(
                `../../src/image/sessionImgsSimple/${i + 1}.png`,
                tipX,
                tipY,
                tipWindowSize,
                tipWindowSize
              )
              // console.log(`../../src/image/sessionImgsSimple/${i + 1}.png`)
            } else if (useMode === 1) {
              img = svg.image(
                `../../src/image/sessionImgsSimpleSpecialR/${i + 1}.png`,
                tipX,
                tipY,
                tipWindowSize,
                tipWindowSize
              )
            } else {
              img = svg.image(
                `../../src/image/MiniMapsR/${i + 1}.png`,
                tipX,
                tipY,
                tipWindowSize,
                tipWindowSize
              )
            }
            img.attr({
              mask: mask,
            })
          },
          () => {
            mask.remove()
            img.remove()
          }
        )
      svg
        .text(
          textXPosTwo,
          localHeight + yOrigin - lineHeight / 2,
          locationSet[i]
        )
        .attr({ 'font-size': 17 })
        .hover(
          event => {
            pt.x = event.clientX
            pt.y = event.clientY

            pt = pt.matrixTransform(mySvg.getScreenCTM().inverse())

            const tipWindowSize = 200
            const maskSize = 200

            let tipX = pt.x
            let tipY = pt.y

            tipX -= 200

            if (i > 4) {
              // tipX -= 100
              tipY -= 100
            }

            mask = svg
              .rect(tipX, tipY, maskSize, maskSize, 10, 10)
              .attr({ fill: 'yellow' })
            // draw for complex and simple version
            if (useMode === 0) {
              img = svg.image(
                `../../src/image/sessionImgsSimple/${i + 1}.png`,
                tipX,
                tipY,
                tipWindowSize,
                tipWindowSize
              )
              // console.log(`../../src/image/sessionImgsSimple/${i + 1}.png`)
            } else if (useMode === 1) {
              img = svg.image(
                `../../src/image/sessionImgsSimpleSpecialR/${i + 1}.png`,
                tipX,
                tipY,
                tipWindowSize,
                tipWindowSize
              )
            } else {
              img = svg.image(
                `../../src/image/MiniMapsR/${i + 1}.png`,
                tipX,
                tipY,
                tipWindowSize,
                tipWindowSize
              )
            }
            img.attr({
              mask: mask,
            })
          },
          () => {
            mask.remove()
            img.remove()
          }
        )
    }

    if ((i + 1) % 2 === 0) {
      rect[i] = svg
        .rect(xOrigin, lineHeight * i + yOrigin, width, lineHeight)
        .attr({
          fill: 'rgba(255, 255, 255, 0.1)',
          stroke: 'none',
        })
      // console.log('y Value: ' + lineHeight * i + yOrigin)
      svg
        .text(
          textXPosOne,
          localHeight + yOrigin - lineHeight / 2,
          locationSet[i]
        )
        .attr({ 'font-size': 17 })
        .hover(
          event => {
            pt.x = event.clientX
            pt.y = event.clientY

            pt = pt.matrixTransform(mySvg.getScreenCTM().inverse())

            const tipWindowSize = 200
            const maskSize = 200

            let tipX = pt.x
            let tipY = pt.y

            if (i > 4) {
              // tipX -= 100
              tipY -= 100
            }

            mask = svg
              .rect(tipX, tipY, maskSize, maskSize, 10, 10)
              .attr({ fill: 'yellow' })
            // draw for complex and simple version
            if (useMode === 0) {
              img = svg.image(
                `../../src/image/sessionImgsSimple/${i + 1}.png`,
                tipX,
                tipY,
                tipWindowSize,
                tipWindowSize
              )
            } else if (useMode === 1) {
              img = svg.image(
                `../../src/image/sessionImgsSimpleSpecialR/${i + 1}.png`,
                tipX,
                tipY,
                tipWindowSize,
                tipWindowSize
              )
            } else {
              img = svg.image(
                `../../src/image/MiniMapsR/${i + 1}.png`,
                tipX,
                tipY,
                tipWindowSize,
                tipWindowSize
              )
            }
            img.attr({
              mask: mask,
            })
          },
          () => {
            mask.remove()
            img.remove()
          }
        )

      svg
        .text(
          textXPosTwo,
          localHeight + yOrigin - lineHeight / 2,
          locationSet[i]
        )
        .attr({ 'font-size': 17 })
        .hover(
          event => {
            pt.x = event.clientX
            pt.y = event.clientY

            pt = pt.matrixTransform(mySvg.getScreenCTM().inverse())

            const tipWindowSize = 200
            const maskSize = 200

            let tipX = pt.x
            let tipY = pt.y

            tipX -= 200

            if (i > 4) {
              // tipX -= 100
              tipY -= 100
            }

            mask = svg
              .rect(tipX, tipY, maskSize, maskSize, 10, 10)
              .attr({ fill: 'yellow' })
            // draw for complex and simple version
            if (useMode === 0) {
              img = svg.image(
                `../../src/image/sessionImgsSimple/${i + 1}.png`,
                tipX,
                tipY,
                tipWindowSize,
                tipWindowSize
              )
            } else if (useMode === 1) {
              img = svg.image(
                `../../src/image/sessionImgsSimpleSpecialR/${i + 1}.png`,
                tipX,
                tipY,
                tipWindowSize,
                tipWindowSize
              )
            } else {
              img = svg.image(
                `../../src/image/MiniMapsR/${i + 1}.png`,
                tipX,
                tipY,
                tipWindowSize,
                tipWindowSize
              )
            }
            img.attr({
              mask: mask,
            })
          },
          () => {
            mask.remove()
            img.remove()
          }
        )
    }
  }

  let border

  let text

  for (let i = 0; i < length; i++) {
    rect[i].mousedown(() => {
      // console.log(rect[i])

      pt.x = event.clientX
      pt.y = event.clientY
      pt = pt.matrixTransform(mySvg.getScreenCTM().inverse())

      const mapSize = 200

      let tipX = pt.x
      let tipY = pt.y

      if (pt.y >= 800) {
        tipY -= 280
      }

      border = svg.rect(tipX, tipY, 250, 280, 10, 10).attr({
        stroke: 'black',
        fill: 'rgba(255,255,255, 0.9)',
        strokeWidth: '3px',
      })

      mask = svg
        .rect(tipX + 25, tipY + 50, mapSize, mapSize, 10, 10)
        .attr({ fill: 'rgba(225, 225, 0)' })
      if (useMode === 0) {
        img = svg.image(
          `../../src/image/sessionImgsSimple/${i + 1}.png`,
          tipX + 25,
          tipY + 50,
          mapSize,
          mapSize
        )
      } else if (useMode === 1) {
        img = svg.image(
          `../../src/image/sessionImgsSimpleSpecialR/${i + 1}.png`,
          tipX + 25,
          tipY + 50,
          mapSize,
          mapSize
        )
      } else {
        img = svg.image(
          `../../src/image/MiniMapsR/${i + 1}.png`,
          tipX + 25,
          tipY + 50,
          mapSize,
          mapSize
        )
      }

      img.attr({
        mask: mask,
      })

      text = svg
        .text(tipX + 28, tipY + 35, locationSet[i])
        .attr('pointer-events', 'none')
        .attr({ 'font-size': 20 })
    })
    rect[i].drag(() => {
      console.log('REMOVE')
      border.remove()
      img.remove()
      mask.remove()
      text.remove()
      event.preventDefault()
    })
    rect[i].mouseup(() => {
      console.log('REMOVE')
      border.remove()
      img.remove()
      mask.remove()
      text.remove()
      event.preventDefault()
    })
  }
}

// Utility function to parse hh:mm:ss.SSS to seconds
function parseTimeToSeconds(timeStr) {
  if (!timeStr) return 0;
  const parts = timeStr.split(':');
  if (parts.length !== 3) return 0;
  const [hh, mm, ss] = parts;
  return (
    parseInt(hh, 10) * 3600 +
    parseInt(mm, 10) * 60 +
    parseFloat(ss.replace(',', '.'))
  );
}

// Get video clip range from event object and optional range (default 5s)
function getVideoClipRangeFromEvent(eventObj, rangeSec = 5) {
  const center = parseTimeToSeconds(eventObj.originalTime);
  return {
    start: Math.max(center - rangeSec, 0),
    end: center + rangeSec
  };
}

async function drawEvents(graph, participantsInfo, filterTypes = null) {
  // Remove previously drawn event icons/groups (if any)
  // We'll use a class for all event icons for easy removal
  svg.selectAll('.event-icon-group').forEach(function(g) {
    g.remove()
  })

  // Remove previously drawn mock event lines (if any)
  svg.selectAll('.mock-event-dotted-line').forEach(function(g) {
    g.remove()
  })

  // Use allEventData if available, otherwise fallback to jsonReadTwo
  let dataPromise = allEventData.length
    ? Promise.resolve(allEventData)
    : jsonReadTwo

  await dataPromise.then(function(result) {
    const data = result

    // --- Draw dotted lines for paired Mock events ---
    // Only draw if 'Mock' is in filterTypes (or if filterTypes is null/undefined)
    let showMockLines = !filterTypes || filterTypes.includes('Mock')
    // --- New logic: group-based vertical dotted line for each Mock event ---
    if (showMockLines) {
      let mockEvents = []
      for (let i = 0; i < data.length; i++) {
        if (data[i]['eventType'] === 'Mock') {
          mockEvents.push({
            idx: i,
            interactor: data[i]['interactor'],
            interactee: data[i]['interactee'],
            timestamp: data[i]['timestamp'],
            interactorID: data[i]['interactorID'],
            interacteeID: data[i]['interacteeID'],
          })
        }
      }
      // For each Mock event, collect all participant positions (interactor + interactees)
      for (let i = 0; i < mockEvents.length; i++) {
        const ev = mockEvents[i]
        const timestamp = ev.timestamp
        // Always treat interactee/interacteeID as arrays
        let interacteeArr = Array.isArray(ev.interacteeID) ? ev.interacteeID : [ev.interacteeID]
        let allIDs = [ev.interactorID, ...interacteeArr]
        let allPlayers = allIDs.map(id => 'Player' + String(id))
        let points = allPlayers.map(pid => [
          graph.getCharacterX(pid, timestamp),
          graph.getCharacterY(pid, timestamp)
        ])
        // Sort by y (vertical) position
        points.sort((a, b) => a[1] - b[1])
        // Draw vertical dotted line connecting all points
        for (let j = 0; j < points.length - 1; j++) {
          svg.line(points[j][0], points[j][1], points[j+1][0], points[j+1][1])
            .attr({
              stroke: '#222',
              'stroke-width': 2,
              'stroke-dasharray': '6,6',
              class: 'mock-event-dotted-line'
            })
        }
      }
    }
    // --- End new group-based dotted line logic ---

    for (let i in data) {
      let eventType = data[i]['eventType']
      if (filterTypes && !filterTypes.includes(eventType)) continue // Filter out unwanted types

      // let posX = data[i]['position']['x']
      // let posY = data[i]['position']['y']
      let interactee = data[i]['interactee']
      let interactor = data[i]['interactor']

      let border

      let interacteeText, interactorText

      let interacteeIcon, interactorIcon

      let interactorBorder

      let eventInfo

      let interacteeNameElement, interactorNameElement

      // General visualizations with icons and tooltips + video
      if (eventType === 'Relocation' || eventType === 'System_Sim_Status') {
        const iconSize = 30
        const offset = iconSize / 2

        let playerIndex = data[i]['interactorID']
        let currentTimestamp = data[i]['timestamp']
        let currentPlayer = 'Player' + String(playerIndex)

        let eventDetails = data[i]['eventDetails']

        let deathPosX = graph.getCharacterX(currentPlayer, currentTimestamp)
        let deathPosY = graph.getCharacterY(currentPlayer, currentTimestamp)

        // Player Icon
        let indexHolder = currentPlayer.match(/\d/g)
        indexHolder = indexHolder.join('')

        svg
          .image(
            `../../src/image/Events_General/${eventType}.png`,
            deathPosX - offset,
            deathPosY - offset,
            iconSize,
            iconSize
          )
          .attr({ class: 'event-icon-group' })
          .hover(
            event => {
              pt.x = event.clientX
              pt.y = event.clientY

              pt = pt.matrixTransform(mySvg.getScreenCTM().inverse())

              let tipX = pt.x
              let tipY = pt.y

              if (pt.y >= 950) {
                tipY -= 50
              }

              if (pt.x >= 5700) {
                tipX -= 200
              }

              currentPlayer = 'Player' + String(playerIndex)

              let length

              if (calculateBorderLength(eventDetails, 50) <= 370) {
                length = 380
              } else {
                length = calculateBorderLength(eventDetails, 50)
              }

              border = svg.rect(tipX, tipY, length, 400, 10, 10).attr({
                stroke: 'black',
                fill: 'rgba(255,255,255, 0.9)',
                strokeWidth: '3px',
              })

              // Remove any existing wrapper before creating a new one
              let oldWrapper = document.getElementById(
                'relocation-tooltip-wrapper'
              )
              if (oldWrapper) {
                let oldVideo = oldWrapper.querySelector(
                  '#relocation-tooltip-video'
                )
                if (oldVideo) oldVideo.pause()
                oldWrapper.remove()
              }

              // Add video element to tooltip, positioned and scaled to match SVG border
              // Remove any existing wrapper before creating a new one
              let wrapper = document.createElement('div')
              wrapper.style.position = 'fixed'
              wrapper.setAttribute('id', 'relocation-tooltip-wrapper')
              wrapper.style.zIndex = 1000
              wrapper.style.pointerEvents = 'none'
              wrapper.style.overflow = 'hidden'
              wrapper.style.scrollbarWidth = 'none'
              wrapper.style.msOverflowStyle = 'none'

              // Get the SVG border's bounding box in SVG coordinates
              let borderBBox = border.node.getBBox()
              // Convert SVG coordinates to screen coordinates
              let ctm = mySvg.getScreenCTM()
              // Top-left corner
              let svgX = borderBBox.x
              let svgY = borderBBox.y
              let svgW = borderBBox.width
              let svgH = borderBBox.height
              // Transform to screen coordinates
              let topLeft = mySvg.createSVGPoint()
              topLeft.x = svgX
              topLeft.y = svgY
              topLeft = topLeft.matrixTransform(ctm)
              // Bottom-right corner
              let bottomRight = mySvg.createSVGPoint()
              bottomRight.x = svgX + svgW
              bottomRight.y = svgY + svgH
              bottomRight = bottomRight.matrixTransform(ctm)
              // Calculate width/height in screen space
              let screenW = bottomRight.x - topLeft.x
              let screenH = bottomRight.y - topLeft.y
              // Set wrapper position and size
              wrapper.style.left = `${topLeft.x}px`
              wrapper.style.top = `${topLeft.y}px`
              wrapper.style.width = `${screenW}px`
              wrapper.style.height = `${screenH}px`

              // Calculate video size and position (2% padding on each side)
              let videoW = screenW * 0.96
              let videoH = screenH * 0.96
              let videoLeft = screenW * 0.2
              let videoTop = screenH * 0.35

              let video = document.createElement('video')
              video.src = '../../src/video/sims4.mp4'
              video.width = videoW
              video.height = videoH
              video.controls = true
              video.autoplay = true
              video.loop = true
              video.muted = true
              video.setAttribute('id', 'relocation-tooltip-video')
              video.style.pointerEvents = 'auto'
              video.style.background = 'black'
              video.style.position = 'absolute'
              video.style.left = `${videoLeft}px`
              video.style.top = `${videoTop}px`
              video.style.width = `${videoW*0.6}px`
              video.style.height = `${videoH*0.6}px`
              video.style.borderRadius = '8px'

              // Clip video to play only within the calculated range and loop
              const videoRange = getVideoClipRangeFromEvent(data[i], 5); // use the current event object
              video.addEventListener('loadedmetadata', function() {
                // Clamp end to video duration if needed
                const end = Math.min(videoRange.end, video.duration);
                video.currentTime = videoRange.start;
                video._clipStart = videoRange.start;
                video._clipEnd = end;
                const playPromise = video.play();
                if (playPromise !== undefined) {
                  playPromise.catch(e => {
                    console.warn('Autoplay play() failed:', e);
                  });
                }
              });
              video.addEventListener('timeupdate', function() {
                // Loop only within the clip range
                if (video.currentTime < video._clipStart || video.currentTime >= video._clipEnd) {
                  video.currentTime = video._clipStart;
                  video.play();
                }
              });

              wrapper.appendChild(video)
              document.body.appendChild(wrapper)

              interactorText = svg.text(
                35 + tipX,
                25 + tipY,
                'Interactor: ' + interactor
              )

              interactorIcon = svg.image(
                `../../src/image/Characters/${interactor}.png`,
                38 + tipX,
                40 + tipY,
                40,
                40
              )

              interactorNameElement = svg.text(
                35 + tipX,
                35 + 50 + 20 + tipY,
                eventDetails
              )

              interactorBorder = svg.rect(35 + tipX, 37 + tipY, 46, 46).attr({
                fill: 'none',
                stroke: `${playerColour[currentPlayer]}`,
                'stroke-width': '3',
                opacity: 0.7,
              })
            },
            () => {
              border.remove()
              interactorText.remove()
              interactorIcon.remove()
              interactorNameElement.remove()
              interactorBorder.remove()
              // Remove the video wrapper if it exists
              let wrapper = document.getElementById(
                'relocation-tooltip-wrapper'
              )
              if (wrapper) {
                let video = wrapper.querySelector('#relocation-tooltip-video')
                if (video) {
                  video.pause()
                }
                wrapper.remove()
              }
            }
          )
      }

      // General visualizations with icons and tooltips (no video)
      // if (eventType === 'Sleep') {
      //   const iconSize = 30
      //   const offset = iconSize / 2
      //
      //   let playerIndex = data[i]['interactorID']
      //   let currentTimestamp = data[i]['timestamp']
      //   let currentPlayer = 'Player' + String(playerIndex)
      //
      //   let eventDetails = data[i]['eventDetails']
      //
      //   let deathPosX = graph.getCharacterX(currentPlayer, currentTimestamp)
      //   let deathPosY = graph.getCharacterY(currentPlayer, currentTimestamp)
      //
      //   // console.log(eventDetails, deathPosX, deathPosY)
      //
      //   // Player Icon
      //   let indexHolder = currentPlayer.match(/\d/g)
      //   indexHolder = indexHolder.join('')
      //
      //   svg
      //     .image(
      //       `../../src/image/Events_General/${eventType}.svg`,
      //       deathPosX - offset,
      //       deathPosY - offset,
      //       iconSize,
      //       iconSize
      //     )
      //     .attr({ class: 'event-icon-group' })
      //     .hover(
      //       event => {
      //         pt.x = event.clientX
      //         pt.y = event.clientY
      //
      //         pt = pt.matrixTransform(mySvg.getScreenCTM().inverse())
      //
      //         // const mapSize = 200
      //
      //         let tipX = pt.x
      //         let tipY = pt.y
      //
      //         console.log(tipX, tipY)
      //
      //         // console.log(currentTimestamp, deathPosX, deathPosY)
      //
      //         if (pt.y >= 950) {
      //           // tipX -= 100
      //           tipY -= 50 // was 200 before
      //         }
      //
      //         if (pt.x >= 5700) {
      //           tipX -= 200
      //         }
      //
      //         currentPlayer = 'Player' + String(playerIndex)
      //
      //         let length
      //
      //         if (calculateBorderLength(eventDetails, 50) < 250) {
      //           length = 250
      //         } else {
      //           length = calculateBorderLength(eventDetails, 50)
      //         }
      //
      //         // backup arg with minimap - tipX, tipY, 250, 325, 10, 10
      //         border = svg.rect(tipX, tipY, length, 125, 10, 10).attr({
      //           stroke: 'black',
      //           fill: 'rgba(255,255,255, 0.9)',
      //           strokeWidth: '3px',
      //         })
      //
      //         // interacteeText = svg.text(130 + tipX, 25 + tipY, 'Interactee: ')
      //         interactorText = svg.text(
      //           35 + tipX,
      //           25 + tipY,
      //           'Interactor: ' + interactor
      //         )
      //
      //         interactorIcon = svg.image(
      //           `../../src/image/Characters/${interactor}.png`, // hardcoded for now
      //           38 + tipX,
      //           40 + tipY,
      //           40,
      //           40
      //         )
      //
      //         // interactorBorder = svg.rect(130 + tipX, 37 + tipY, 46, 46).attr({
      //         //   fill: 'none',
      //         //   stroke: `${playerColour[currentPlayer]}`,
      //         //   'stroke-width': '3',
      //         //   opacity: 0.7,
      //         // })
      //
      //         interactorNameElement = svg.text(
      //           35 + tipX,
      //           35 + 50 + 20 + tipY,
      //           eventDetails
      //         )
      //       },
      //       () => {
      //         border.remove()
      //         interactorText.remove()
      //         interactorIcon.remove()
      //         interactorNameElement.remove()
      //       }
      //     )
      // }

      // draw rectangle with gradient fill for Moving_In event
      if (eventType === 'Moving_In') {
        // Rectangle size
        const rectWidth = 30
        const rectHeight = 70

        let playerIndex = data[i]['interactorID']
        let currentTimestamp = data[i]['timestamp']
        let currentPlayer = 'Player' + String(playerIndex)

        let eventDetails = data[i]['eventDetails']

        let deathPosX = graph.getCharacterX(currentPlayer, currentTimestamp)
        let deathPosY = graph.getCharacterY(currentPlayer, currentTimestamp)

        // Gradient definition
        // Remove any previous gradient with same id to avoid duplicates
        let gradId = `movingin-gradient-${playerIndex}`
        // Remove any existing gradient with this id in <defs>
        let defs = svg.select('defs');
        if (!defs) {
          defs = svg.paper.el('defs');
          svg.append(defs);
        }
        let oldGrad = defs.select(`#${gradId}`);
        if (oldGrad) {
          oldGrad.remove();
        }
        // Create a proper SVG linearGradient element
        let gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
        gradient.setAttribute('id', gradId);
        gradient.setAttribute('x1', '0%');
        gradient.setAttribute('y1', '0%');
        gradient.setAttribute('x2', '100%');
        gradient.setAttribute('y2', '0%');
        // Start colour stop
        let stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop1.setAttribute('offset', '0%');
        stop1.setAttribute('stop-color', playerColour[currentPlayer]);
        stop1.setAttribute('stop-opacity', '0.7');
        // End transparent stop
        let stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
        stop2.setAttribute('offset', '100%');
        stop2.setAttribute('stop-color', playerColour[currentPlayer]);
        stop2.setAttribute('stop-opacity', '0');
        gradient.appendChild(stop1);
        gradient.appendChild(stop2);
        defs.node.appendChild(gradient);

        // Draw the rectangle with gradient fill
        let rect = svg
          .rect(
            deathPosX - rectWidth / 2,
            deathPosY - rectHeight / 2,
            rectWidth,
            rectHeight,
            8, // rx for rounded corners
            8  // ry for rounded corners
          )
          .attr({
            fill: `url(#${gradId})`,
            class: 'event-icon-group'
          })

        rect.hover(
          event => {
            pt.x = event.clientX
            pt.y = event.clientY

            pt = pt.matrixTransform(mySvg.getScreenCTM().inverse())

            let tipX = pt.x
            let tipY = pt.y

            if (pt.y >= 950) {
              tipY -= 50
            }

            if (pt.x >= 5700) {
              tipX -= 200
            }

            currentPlayer = 'Player' + String(playerIndex)

            let length

            if (calculateBorderLength(eventDetails, 50) < 250) {
              length = 250
            } else {
              length = calculateBorderLength(eventDetails, 50)
            }

            border = svg.rect(tipX, tipY, length, 125, 10, 10).attr({
              stroke: 'black',
              fill: 'rgba(255,255,255, 0.9)',
              strokeWidth: '3px',
            })

            interactorText = svg.text(
              35 + tipX,
              25 + tipY,
              'Interactor: ' + interactor
            )

            interactorIcon = svg.image(
              `../../src/image/Characters/${interactor}.png`,
              38 + tipX,
              40 + tipY,
              40,
              40
            )

            interactorNameElement = svg.text(
              35 + tipX,
              35 + 50 + 20 + tipY,
              eventDetails
            )

            interactorBorder = svg.rect(35 + tipX, 37 + tipY, 46, 46).attr({
              fill: 'none',
              stroke: `${playerColour[currentPlayer]}`,
              'stroke-width': '3',
              opacity: 0.7,
            })
          },
          () => {
            border.remove()
            interactorText.remove()
            interactorIcon.remove()
            interactorNameElement.remove()
            interactorBorder.remove()
          }
        )
      }

      // this contains the logic for connecting events with multiple participants
      if (eventType === 'Mock') {
        // Rectangle size
        const rectWidth = 15
        const rectHeight = 20

        let playerIndex = data[i]['interactorID']
        let currentTimestamp = data[i]['timestamp']
        let currentPlayer = 'Player' + String(playerIndex)
        let eventDetails = data[i]['eventDetails']

        // Always treat interactee/interacteeID as arrays
        let interacteeArr = Array.isArray(data[i]['interacteeID']) ? data[i]['interacteeID'] : [data[i]['interacteeID']]
        let interacteeNameArr = Array.isArray(data[i]['interactee']) ? data[i]['interactee'] : [data[i]['interactee']]
        // Collect all participants: interactor + interactees
        let allIDs = [data[i]['interactorID'], ...interacteeArr]
        let allNames = [data[i]['interactor'], ...interacteeNameArr]
        let allPlayers = allIDs.map(id => 'Player' + String(id))
        let allRects = []
        for (let k = 0; k < allPlayers.length; k++) {
          let posX = graph.getCharacterX(allPlayers[k], currentTimestamp)
          let posY = graph.getCharacterY(allPlayers[k], currentTimestamp)
          // Pattern definition for black stripes
          let patternId = 'mock-stripes-pattern'
          let defs = svg.select('defs');
          if (!defs) {
            defs = svg.paper.el('defs');
            svg.append(defs);
          }
          let oldPattern = defs.select(`#${patternId}`);
          if (oldPattern) {
            oldPattern.remove();
          }
          let pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
          pattern.setAttribute('id', patternId);
          pattern.setAttribute('patternUnits', 'userSpaceOnUse');
          pattern.setAttribute('width', '8');
          pattern.setAttribute('height', '8');
          let stripe1 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          stripe1.setAttribute('x', '0');
          stripe1.setAttribute('y', '0');
          stripe1.setAttribute('width', '8');
          stripe1.setAttribute('height', '8');
          stripe1.setAttribute('fill', 'white');
          pattern.appendChild(stripe1);
          let line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          line.setAttribute('d', 'M0,0 l10,10');
          line.setAttribute('stroke', 'black');
          line.setAttribute('stroke-width', '2');
          pattern.appendChild(line);
          defs.node.appendChild(pattern);
          // Draw the rectangle with pattern fill
          let rect = svg
            .rect(
              posX - rectWidth / 2,
              posY - rectHeight / 2,
              rectWidth,
              rectHeight,
              8, // rx for rounded corners
              8  // ry for rounded corners
            )
            .attr({
              fill: `url(#${patternId})`,
              class: 'event-icon-group'
            })
          // Add hover for each rectangle
          rect.hover(
            event => {
              pt.x = event.clientX
              pt.y = event.clientY
              pt = pt.matrixTransform(mySvg.getScreenCTM().inverse())
              let tipX = pt.x
              let tipY = pt.y
              if (pt.y >= 950) tipY -= 50
              if (pt.x >= 5700) tipX -= 200
              let length = calculateBorderLength(eventDetails, 50) < 250 ? 250 : calculateBorderLength(eventDetails, 50)
              border = svg.rect(tipX, tipY, length, 400, 10, 10).attr({
                stroke: 'black',
                fill: 'rgba(255,255,255, 0.9)',
                strokeWidth: '3px',
              })
              interactorText = svg.text(
                35 + tipX,
                25 + tipY,
                'Character Involved: ' + allNames[k]
              )
              interactorIcon = svg.image(
                `../../src/image/Characters/${allNames[k]}.png`,
                38 + tipX,
                40 + tipY,
                40,
                40
              )
              interactorNameElement = svg.text(
                35 + tipX,
                35 + 50 + 20 + tipY,
                eventDetails
              )
              // Set border color to match storyline color for this character
              let storylineColor = playerColour[allPlayers[k]] || '#222';
              interactorBorder = svg.rect(35 + tipX, 37 + tipY, 46, 46).attr({
                fill: 'none',
                stroke: storylineColor,
                'stroke-width': '3',
                opacity: 0.7,
              })

              // Remove any existing wrapper before creating a new one
              let oldWrapper = document.getElementById(
                'relocation-tooltip-wrapper'
              )
              if (oldWrapper) {
                let oldVideo = oldWrapper.querySelector(
                  '#relocation-tooltip-video'
                )
                if (oldVideo) oldVideo.pause()
                oldWrapper.remove()
              }

              // Add video element to tooltip, positioned and scaled to match SVG border
              // Remove any existing wrapper before creating a new one
              let wrapper = document.createElement('div')
              wrapper.style.position = 'fixed'
              wrapper.setAttribute('id', 'relocation-tooltip-wrapper')
              wrapper.style.zIndex = 1000
              wrapper.style.pointerEvents = 'none'
              wrapper.style.overflow = 'hidden'
              wrapper.style.scrollbarWidth = 'none'
              wrapper.style.msOverflowStyle = 'none'

              // Get the SVG border's bounding box in SVG coordinates
              let borderBBox = border.node.getBBox()
              // Convert SVG coordinates to screen coordinates
              let ctm = mySvg.getScreenCTM()
              // Top-left corner
              let svgX = borderBBox.x
              let svgY = borderBBox.y
              let svgW = borderBBox.width
              let svgH = borderBBox.height
              // Transform to screen coordinates
              let topLeft = mySvg.createSVGPoint()
              topLeft.x = svgX
              topLeft.y = svgY
              topLeft = topLeft.matrixTransform(ctm)
              // Bottom-right corner
              let bottomRight = mySvg.createSVGPoint()
              bottomRight.x = svgX + svgW
              bottomRight.y = svgY + svgH
              bottomRight = bottomRight.matrixTransform(ctm)
              // Calculate width/height in screen space
              let screenW = bottomRight.x - topLeft.x
              let screenH = bottomRight.y - topLeft.y
              // Set wrapper position and size
              wrapper.style.left = `${topLeft.x}px`
              wrapper.style.top = `${topLeft.y}px`
              wrapper.style.width = `${screenW}px`
              wrapper.style.height = `${screenH}px`

              // Calculate video size and position (2% padding on each side)
              let videoW = screenW * 0.96
              let videoH = screenH * 0.96
              let videoLeft = screenW * 0.2
              let videoTop = screenH * 0.35

              let video = document.createElement('video')
              video.src = '../../src/video/sims4.mp4'
              video.width = videoW
              video.height = videoH
              video.controls = true
              video.autoplay = true
              video.loop = true
              video.muted = true
              video.setAttribute('id', 'relocation-tooltip-video')
              video.style.pointerEvents = 'auto'
              video.style.background = 'black'
              video.style.position = 'absolute'
              video.style.left = `${videoLeft}px`
              video.style.top = `${videoTop}px`
              video.style.width = `${videoW*0.6}px`
              video.style.height = `${videoH*0.6}px`
              video.style.borderRadius = '8px'

              // Clip video to play only within the calculated range and loop
              const videoRange = getVideoClipRangeFromEvent(data[i], 5); // use the current event object
              video.addEventListener('loadedmetadata', function() {
                // Clamp end to video duration if needed
                const end = Math.min(videoRange.end, video.duration);
                video.currentTime = videoRange.start;
                video._clipStart = videoRange.start;
                video._clipEnd = end;
                const playPromise = video.play();
                if (playPromise !== undefined) {
                  playPromise.catch(e => {
                    console.warn('Autoplay play() failed:', e);
                  });
                }
              });
              video.addEventListener('timeupdate', function() {
                // Loop only within the clip range
                if (video.currentTime < video._clipStart || video.currentTime >= video._clipEnd) {
                  video.currentTime = video._clipStart;
                  video.play();
                }
              });

              wrapper.appendChild(video)
              document.body.appendChild(wrapper)
            },
            () => {
              border.remove()
              interactorText.remove()
              interactorIcon.remove()
              interactorNameElement.remove()
              interactorBorder.remove()
              // Remove the video wrapper if it exists
              let wrapper = document.getElementById(
                'relocation-tooltip-wrapper'
              )
              if (wrapper) {
                let video = wrapper.querySelector('#relocation-tooltip-video')
                if (video) {
                  video.pause()
                }
                wrapper.remove()
              }
            }
          )
          allRects.push(rect)
        }
        // No need to draw lines here; handled above for all participants
      }

      // different size for death icon + video in tooltip
      if (eventType === 'Death') {
        const iconSize = 50
        const offset = iconSize / 2

        let playerIndex = data[i]['interactorID']
        let currentTimestamp = data[i]['timestamp']
        let currentPlayer = 'Player' + String(playerIndex)

        let eventDetails = data[i]['eventDetails']

        let deathPosX = graph.getCharacterX(currentPlayer, currentTimestamp)
        let deathPosY = graph.getCharacterY(currentPlayer, currentTimestamp)

        // console.log(eventDetails, deathPosX, deathPosY)

        // Player Icon
        let indexHolder = currentPlayer.match(/\d/g)
        indexHolder = indexHolder.join('')

        svg
          .image(
            `../../src/image/Events_General/${eventType}.svg`,
            deathPosX - offset,
            deathPosY - offset,
            iconSize,
            iconSize
          )
          .attr({ class: 'event-icon-group' })
          .hover(
            event => {
              pt.x = event.clientX
              pt.y = event.clientY

              pt = pt.matrixTransform(mySvg.getScreenCTM().inverse())

              // const mapSize = 200

              let tipX = pt.x
              let tipY = pt.y

              console.log(tipX, tipY)

              // console.log(currentTimestamp, deathPosX, deathPosY)

              if (pt.y >= 950) {
                // tipX -= 100
                tipY -= 50 // was 200 before
              }

              if (pt.x >= 5700) {
                tipX -= 200
              }

              currentPlayer = 'Player' + String(playerIndex)

              let length

              if (calculateBorderLength(eventDetails, 50) < 250) {
                length = 250
              } else {
                length = calculateBorderLength(eventDetails, 50)
              }

              // backup arg with minimap - tipX, tipY, 250, 325, 10, 10
              border = svg.rect(tipX, tipY, length, 400, 10, 10).attr({
                stroke: 'black',
                fill: 'rgba(255,255,255, 0.9)',
                strokeWidth: '3px',
              })

              // interacteeText = svg.text(130 + tipX, 25 + tipY, 'Interactee: ')
              interactorText = svg.text(
                35 + tipX,
                25 + tipY,
                'Interactor: ' + interactor
              )

              interactorIcon = svg.image(
                `../../src/image/Characters/${interactor}.png`, // hardcoded for now
                38 + tipX,
                40 + tipY,
                40,
                40
              )

              interactorBorder = svg.rect(35 + tipX, 37 + tipY, 46, 46).attr({
                fill: 'none',
                stroke: `${playerColour[currentPlayer]}`,
                'stroke-width': '3',
                opacity: 0.7,
              })

              // Remove any existing wrapper before creating a new one
              let oldWrapper = document.getElementById(
                'relocation-tooltip-wrapper'
              )
              if (oldWrapper) {
                let oldVideo = oldWrapper.querySelector(
                  '#relocation-tooltip-video'
                )
                if (oldVideo) oldVideo.pause()
                oldWrapper.remove()
              }

              // Add video element to tooltip, positioned and scaled to match SVG border
              // Remove any existing wrapper before creating a new one
              let wrapper = document.createElement('div')
              wrapper.style.position = 'fixed'
              wrapper.setAttribute('id', 'relocation-tooltip-wrapper')
              wrapper.style.zIndex = 1000
              wrapper.style.pointerEvents = 'none'
              wrapper.style.overflow = 'hidden'
              wrapper.style.scrollbarWidth = 'none'
              wrapper.style.msOverflowStyle = 'none'

              // Get the SVG border's bounding box in SVG coordinates
              let borderBBox = border.node.getBBox()
              // Convert SVG coordinates to screen coordinates
              let ctm = mySvg.getScreenCTM()
              // Top-left corner
              let svgX = borderBBox.x
              let svgY = borderBBox.y
              let svgW = borderBBox.width
              let svgH = borderBBox.height
              // Transform to screen coordinates
              let topLeft = mySvg.createSVGPoint()
              topLeft.x = svgX
              topLeft.y = svgY
              topLeft = topLeft.matrixTransform(ctm)
              // Bottom-right corner
              let bottomRight = mySvg.createSVGPoint()
              bottomRight.x = svgX + svgW
              bottomRight.y = svgY + svgH
              bottomRight = bottomRight.matrixTransform(ctm)
              // Calculate width/height in screen space
              let screenW = bottomRight.x - topLeft.x
              let screenH = bottomRight.y - topLeft.y
              // Set wrapper position and size
              wrapper.style.left = `${topLeft.x}px`
              wrapper.style.top = `${topLeft.y}px`
              wrapper.style.width = `${screenW}px`
              wrapper.style.height = `${screenH}px`

              // Calculate video size and position (2% padding on each side)
              let videoW = screenW * 0.96
              let videoH = screenH * 0.96
              let videoLeft = screenW * 0.2
              let videoTop = screenH * 0.35

              let video = document.createElement('video')
              video.src = '../../src/video/sims4.mp4'
              video.width = videoW
              video.height = videoH
              video.controls = true
              video.autoplay = true
              video.loop = true
              video.muted = true
              video.setAttribute('id', 'relocation-tooltip-video')
              video.style.pointerEvents = 'auto'
              video.style.background = 'black'
              video.style.position = 'absolute'
              video.style.left = `${videoLeft}px`
              video.style.top = `${videoTop}px`
              video.style.width = `${videoW*0.6}px`
              video.style.height = `${videoH*0.6}px`
              video.style.borderRadius = '8px'

              // Clip video to play only within the calculated range and loop
              const videoRange = getVideoClipRangeFromEvent(data[i], 5); // use the current event object
              video.addEventListener('loadedmetadata', function() {
                // Clamp end to video duration if needed
                const end = Math.min(videoRange.end, video.duration);
                video.currentTime = videoRange.start;
                video._clipStart = videoRange.start;
                video._clipEnd = end;
                const playPromise = video.play();
                if (playPromise !== undefined) {
                  playPromise.catch(e => {
                    console.warn('Autoplay play() failed:', e);
                  });
                }
              });
              video.addEventListener('timeupdate', function() {
                // Loop only within the clip range
                if (video.currentTime < video._clipStart || video.currentTime >= video._clipEnd) {
                  video.currentTime = video._clipStart;
                  video.play();
                }
              });

              wrapper.appendChild(video)
              document.body.appendChild(wrapper)

              interactorNameElement = svg.text(
                35 + tipX,
                35 + 50 + 20 + tipY,
                eventDetails
              )
            },
            () => {
              border.remove()
              interactorText.remove()
              interactorIcon.remove()
              interactorNameElement.remove()
              interactorBorder.remove()
              // Remove the video wrapper if it exists
              let wrapper = document.getElementById(
                'relocation-tooltip-wrapper'
              )
              if (wrapper) {
                let video = wrapper.querySelector('#relocation-tooltip-video')
                if (video) {
                  video.pause()
                }
                wrapper.remove()
              }
            }
          )
      }

      // different size for letter icon, no video in tooltip
      if (eventType === 'Letter') {
        const iconSize = 45
        const offset = iconSize / 2

        let playerIndex = data[i]['interactorID']
        let currentTimestamp = data[i]['timestamp']
        let currentPlayer = 'Player' + String(playerIndex)

        let eventDetails = data[i]['eventDetails']

        let deathPosX = graph.getCharacterX(currentPlayer, currentTimestamp)
        let deathPosY = graph.getCharacterY(currentPlayer, currentTimestamp)

        // console.log(eventDetails, deathPosX, deathPosY)

        // Player Icon
        let indexHolder = currentPlayer.match(/\d/g)
        indexHolder = indexHolder.join('')

        svg
          .image(
            `../../src/image/Events_General/${eventType}.svg`,
            deathPosX - offset,
            deathPosY - offset,
            iconSize,
            iconSize
          )
          .attr({ class: 'event-icon-group' })
          .hover(
            event => {
              pt.x = event.clientX
              pt.y = event.clientY

              pt = pt.matrixTransform(mySvg.getScreenCTM().inverse())

              // const mapSize = 200

              let tipX = pt.x
              let tipY = pt.y

              console.log(tipX, tipY)

              // console.log(currentTimestamp, deathPosX, deathPosY)

              if (pt.y >= 950) {
                // tipX -= 100
                tipY -= 50 // was 200 before
              }

              if (pt.x >= 5700) {
                tipX -= 200
              }

              currentPlayer = 'Player' + String(playerIndex)

              let length

              if (calculateBorderLength(eventDetails, 50) < 250) {
                length = 250
              } else {
                length = calculateBorderLength(eventDetails, 50)
              }

              // backup arg with minimap - tipX, tipY, 250, 325, 10, 10
              border = svg.rect(tipX, tipY, length, 125, 10, 10).attr({
                stroke: 'black',
                fill: 'rgba(255,255,255, 0.9)',
                strokeWidth: '3px',
              })

              // interacteeText = svg.text(130 + tipX, 25 + tipY, 'Interactee: ')
              interactorText = svg.text(
                35 + tipX,
                25 + tipY,
                'Interactor: ' + interactor
              )

              interactorIcon = svg.image(
                `../../src/image/Characters/${interactor}.png`, // hardcoded for now
                38 + tipX,
                40 + tipY,
                40,
                40
              )

              interactorBorder = svg.rect(35 + tipX, 37 + tipY, 46, 46).attr({
                fill: 'none',
                stroke: `${playerColour[currentPlayer]}`,
                'stroke-width': '3',
                opacity: 0.7,
              })

              interactorNameElement = svg.text(
                35 + tipX,
                35 + 50 + 20 + tipY,
                eventDetails
              )
            },
            () => {
              border.remove()
              interactorText.remove()
              interactorIcon.remove()
              interactorNameElement.remove()
              interactorBorder.remove()
            }
          )
      }

      lastTimestamp = data[i]['timestamp']
    }
  })
}

/*function drawDBSCAN(dbSCANData, graph) {
  let dbScanLabel = []

  for (let item in dbSCANData) {
    if (dbScanLabel.indexOf(dbSCANData[item]['label']) === -1) {
      dbScanLabel.push(dbSCANData[item]['label'])
    }
  }
  // console.log(dbScanLabel)

  for (let element in dbScanLabel) {
    let x, y
    let sumX = 0,
      sumY = 0
    let points = []

    for (let item in dbSCANData) {
      if (dbScanLabel[element] == dbSCANData[item]['label']) {
        x = graph.getCharacterX(
          dbSCANData[item]['player'],
          dbSCANData[item]['timestamp']
        )
        y = graph.getCharacterY(
          dbSCANData[item]['player'],
          dbSCANData[item]['timestamp']
        )

        sumX = sumX + x
        sumY = sumY + y

        points.push([x, y])
      }
    }

    shapeCovering(points)
  }
}*/

// function for reversing ID of team members for reversed layout
function reverseId(IdNumber) {
  if (IdNumber > 5) {
    return (IdNumber -= 5)
  } else {
    return (IdNumber += 5)
  }
}

// function main2() {
//   const iStoryliner = new iStoryline()
//   // Scale to window size
//   const containerDom = document.getElementById('mySvg')
//   const windowW = containerDom.clientWidth - 20
//   const windowH = containerDom.clientHeight - 20
//   iStoryliner.addCharacter('tt', [[0, 10], [50, 60]])
//   graph = iStoryliner.scale(10, 10, windowW * 0.8, windowH / 2)
//   logStoryInfo(iStorylineInstance._story)
//   const storylines = graph.storylines
//   storylines.forEach(storyline => drawStoryline(storyline))
// }

// main2()
